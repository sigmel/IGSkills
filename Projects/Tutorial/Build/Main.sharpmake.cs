using Sharpmake; // Contains the entire Sharpmake object library.

[module: Include("../../../Engine/Build/BaseProject.cs")]
[module: Include("../../../Engine/Build/Engine.sharpmake.cs")]

// Represents the project that will be generated by Sharpmake and that contains
// the sample C++ code.
[Generate]
public class TutorialProject : IGSkills.BaseProject
{
	public TutorialProject()
	{
		// The name of the project in Visual Studio. The default is the name of
		// the class, but you usually want to override that.
		Name = "Tutorial";
	}

	// Sets the properties of each configuration (conf) according to the target.
	//
	// This method is called once for every target specified by AddTargets. Since
	// we only want vs2015 targets and we want 32- and 64-bit targets, each having
	// a debug and a release version, we have 1 x 2 x 2 targets to configure, so it
	// will be called 4 times.
	//
	// If we had instead specified vs2012 | vs2015 | vs2017 it would have been
	// called 12 times. (3 x 2 x 2)
	[Configure()]
	public override void ConfigureAll(Project.Configuration conf, Target target)
	{
		base.ConfigureAll(conf, target);
	}
}

// Represents the solution that will be generated and that will contain the
// project with the sample code.
[Generate]
public class TutorialSolution : IGSkills.BaseSolution
{
	public TutorialSolution()
	{
		Name = "Tutorial";
	}

	[Configure()]
	public override void ConfigureAll(Configuration conf, Target target)
	{
		base.ConfigureAll(conf, target);

		conf.AddProject<TutorialProject>(target);
	}
}

public static class Main
{
	[Sharpmake.Main]
	public static void SharpmakeMain(Arguments arguments)
	{
		//KitsRootPaths.SetUseKitsRootForDevEnv(DevEnv.vs2022, KitsRootEnum.KitsRoot10, Options.Vc.General.WindowsTargetPlatformVersion.v10_0_17763_0);

		// Tells Sharpmake to generate the solution described by
		// BasicsSolution.
		arguments.Generate<TutorialSolution>();
	}
}